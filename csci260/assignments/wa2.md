# Written Assignment 2
CHRISTOPHER NILSSEN CSCI 260 F2402
#### 1. Trees
a. Draw the red-black tree generated by inserting the following sequence of numbers one by one into an initially empty red-black tree:
```
{53, 36, 5, 50, 43, 13, 8, 88, 62, 78, 97, 33, 28, 4, 58}
```
Clearly identify the color of each node in the tree.
```
                     50(B)
                /            \
            36(B)             62(B)
            /  \           /        \
         8(R)   43(B)   53(B)       88(B)
        /   \              \       /     \
    5(B)    28(B)          58(R)  78(R)  97(R)
    /      /    \
  4(R)   13(R)  33(R)
```

b. Draw the (2,4)-tree that is equivalent to the above red-black tree.
```
                          [50]
              /                        \
          [8, 36]                       [62]
     /       |        \             /           \
[4, 5]  [13, 28, 33]  [43]     [53, 58]    [78, 88, 97]
```

c. What is an example of the minimum number of data item insertions that would cause an internal node split?
- Let's target the fullest leaf node with the fullest parent ([13, 28, 33] and [8, 36]).
- Inserting **1 number**, 34, causes [13, 28, 33] to overflow and promote to parent, resulting in [8, 34, 36] (now full).
- This also splits the leaf into [13] and [33, 34], meaning we'll need to insert **2 numbers** to cause the parent to split.
- Let's insert at the [4, 5] leaf so as to avoid duplication.
- Inserting 6 and 7 causes an overflow and split, promoting 6 to the parent and causing an overflow and split.
**Conclusion:** It would take at least 3 data items to cause an internal node split ({34, 6, 7}).

---

#### 2. Compute a table representing the KMP failure function for the following pattern string:
`tattarrattat`

I used the KMP algorithm from the class notes (http://csci.viu.ca/~liuh/260/Lectures/Lec09-StringMatching.html) and modified `failure` by adding this:

```cpp
// print the failure function
cout << "Failure function for pattern \"" << p << "\": ";
for (int k = 0; k < lenp; ++k) {
    cout << f[k] << " ";
}
cout << endl;
```

And then I assembled this `main`:

```cpp
int main() {
    string pattern;

    // Input the pattern
    cout << "Enter the pattern: ";
    getline(cin, pattern);

    // Prepare the failure array
    int lenp = pattern.length();
    int f[lenp];

    // Compute and display the failure function
    failure(f, pattern);

    return 0;
}
```

This produced:

```
Enter the pattern: tattarrattat
Failure function for pattern "tattarrattat": 0 0 1 1 2 0 0 0 1 1 2 3
```

---

#### 3. Given the following text string:

huffman encoding algorithm uses optimized variable length bit strings to encode characters in a given string x over some alphabet. the optimization is based on the frequencies of the characters used in string x. the basic idea of the optimization is to use fewer digits to represent the characters with high frequencies. it is a greedy algorithm.

a. Assume the alphabet contains only lower-case letters. Compute the frequency table for letters appearing in the text only. Show both the algorithm used and the resulting table.
b. Draw the Huffman tree based on the frequency table.
c. Show the Huffman code assigned to each letter.

**Algorithm:**
**Input:** A string `S` consisting of lower-case characters, possibly including punctuation and spaces.
**Output:** A frequency table `F` mapping each letter `'a'` to `'z'` to its count in `S`.
**Steps:**
1. **Initialize** an array `F[0..25]` of integers to zero. This array will represent the counts of each letter from `'a'` to `'z'`.
2. **For** each character `c` in the string `S`:
    1. **If** `c` is a lower-case letter between `'a'` and `'z'` (i.e., `if 'a' ≤ c ≤ 'z'`):
        1. Compute the index `i` corresponding to the letter: `i = ord(c) - ord('a')`.
        2. Increment `F[i]` by `1`.
3. **After processing all the characters**, the array `F` contains the frequency of each letter. The frequency of letter `chr(ord('a') + i)` is `F[i]` from `0` to `25`.
4. **Output** the frequency table `F`. Represent as a list of pairs `(letter, count)` for readability.

| char | freq
| :- | :-
| e | 37
| i | 31
| t | 29
| s | 21
| a | 20
| r | 19
| h | 17
| n | 17
| o | 17
| c | 11
| g | 11
| d | 8
| f | 7
| m | 7
| u | 6
| b | 5
| l | 5
| p | 5
| v | 3
| z | 3
| q | 2
| w | 2
| x | 2
| y | 1

**Huffman Tree:**

```
                                  N23(286)
                  /                                    \
          N21(128)                                      N22(158)       
         /      \                                /                     \
  N17(60)         N18(68)                N19(71)                         N20(87)
    /\              /\                 /        \                      /          \
t(29) i(31)   N12(31) e(37)     N13(34)          N14(37)        N15(41)             N16(46)
                   /\              /\                /\           /\                  /\
              N8(14) o(17)    n(17) h(17)       N9(18) r(19)   a(20) s(21)    N10(22)    N11(24)
               /\                                   /\                          /\         /\
          N4(7) f(7)                           N5(10) d(8)                g(11) c(11) N6(11)  N7(13)
            /\                                  /\                                     /\         /\
      N1(3)    N2(4)                         p(5) l(5)                              b(5) u(6) N3(6) m(7)
      /\        /\                                                                             /\
  y(1) x(2)  w(2) q(2)                                                                      z(3) v(3)
```

**Huffman codes:**

| char | code
| :- | :-
| t | 000
| i | 001
| e | 011
| o | 0101
| f | 01001
| y | 0100000
| x | 0100001
| w | 0100010
| q | 0100011
| n | 1000
| h | 1001
| r | 1011
| d | 10101
| p | 101000
| l | 101001
| a | 1100
| s | 1101
| g | 11110
| c | 11111
| b | 111100
| u | 111101
| m | 111111
| z | 1111100
| v | 1111101