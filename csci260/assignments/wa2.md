# Written Assignment 2
CHRISTOPHER NILSSEN CSCI 260 F2402

#### 1. Trees
a. Draw the red-black tree generated by inserting the following sequence of numbers one by one into an initially empty red-black tree:
```
{53, 36, 5, 50, 43, 13, 8, 88, 62, 78, 97, 33, 28, 4, 58}
```
Clearly identify the color of each node in the tree.
```
                     50(B)
                /            \
            36(B)             62(B)
            /  \           /        \
         8(R)   43(B)   53(B)       88(B)
        /   \              \       /     \
    5(B)    28(B)          58(R)  78(R)  97(R)
    /      /    \
  4(R)   13(R)  33(R)
```

b. Draw the (2,4)-tree that is equivalent to the above red-black tree.
```
                          [50]
              /                        \
          [8, 36]                       [62]
     /       |        \             /           \
[4, 5]  [13, 28, 33]  [43]     [53, 58]    [78, 88, 97]
```

c. What is an example of the minimum number of data item insertions that would cause an internal node split?
- Let's target the fullest leaf node with the fullest parent ([13, 28, 33] and [8, 36]).
- Inserting **1 number**, 34, causes [13, 28, 33] to overflow and promote to parent, resulting in [8, 34, 36] (now full).
- This also splits the leaf into [13] and [33, 34], meaning we'll need to insert **2 numbers** to cause the parent to split.
- Let's insert at the [4, 5] leaf so as to avoid duplication.
- Inserting 6 and 7 causes an overflow and split, promoting 6 to the parent and causing an overflow and split.

**Conclusion:** It would take at least 3 data items to cause an internal node split ({34, 6, 7}).

\newpage

#### 2. Compute a table representing the KMP failure function for the following pattern string:
`tattarrattat`

I used the KMP algorithm from the class notes (http://csci.viu.ca/~liuh/260/Lectures/Lec09-StringMatching.html) and modified `failure` by adding this:

```cpp
// print the failure function
cout << "Failure function for pattern \"" << p << "\": ";
for (int k = 0; k < lenp; ++k) {
    cout << f[k] << " ";
}
cout << endl;
```

And then I assembled this `main`:

```cpp
int main() {
    string pattern;

    // Input the pattern
    cout << "Enter the pattern: ";
    getline(cin, pattern);

    // Prepare the failure array
    int lenp = pattern.length();
    int f[lenp];

    // Compute and display the failure function
    failure(f, pattern);

    return 0;
}
```

This produced:

```
Enter the pattern: tattarrattat
Failure function for pattern "tattarrattat": 0 0 1 1 2 0 0 0 1 1 2 3
```

\newpage

#### 3. Given the following text string:

huffman encoding algorithm uses optimized variable length bit strings to encode characters in a given string x over some alphabet. the optimization is based on the frequencies of the characters used in string x. the basic idea of the optimization is to use fewer digits to represent the characters with high frequencies. it is a greedy algorithm.

a. Assume the alphabet contains only lower-case letters. Compute the frequency table for letters appearing in the text only. Show both the algorithm used and the resulting table.
b. Draw the Huffman tree based on the frequency table.
c. Show the Huffman code assigned to each letter.

**Algorithm:**

**Input:** A string `S` consisting of lower-case characters, possibly including punctuation and spaces.

**Output:** A frequency table `F` mapping each letter `'a'` to `'z'` to its count in `S`.

**Steps:**

1. **Initialize** an array `F[0..25]` of integers to zero. This array will represent the counts of each letter from `'a'` to `'z'`.

2. **For** each character `c` in the string `S`:

    1. **If** `c` is a lower-case letter between `'a'` and `'z'` (i.e., `if 'a' <= c <= 'z'`):

        1. Compute the index `i` corresponding to the letter: `i = ord(c) - ord('a')`.

        2. Increment `F[i]` by `1`.

3. **After processing all the characters**, the array `F` contains the frequency of each letter. The frequency of letter `chr(ord('a') + i)` is `F[i]` from `0` to `25`.

4. **Output** the frequency table `F`. Represent as a list of pairs `(letter, count)` for readability.

| char | freq
| :- | :-
| e | 37
| i | 31
| t | 29
| s | 21
| a | 20
| r | 19
| h | 17
| n | 17
| o | 17
| c | 11
| g | 11
| d | 8
| f | 7
| m | 7
| u | 6
| b | 5
| l | 5
| p | 5
| v | 3
| z | 3
| q | 2
| w | 2
| x | 2
| y | 1

\newpage

**Huffman Tree:**

```
                                  N23(286)
                  /                                    \
          N21(128)                                      N22(158)       
         /      \                                /                     \
  N17(60)         N18(68)                N19(71)                         N20(87)
    /\              /\                 /        \                      /          \
t(29) i(31)   N12(31) e(37)     N13(34)          N14(37)        N15(41)             N16(46)
                   /\              /\                /\           /\                  /\
              N8(14) o(17)    n(17) h(17)       N9(18) r(19)   a(20) s(21)    N10(22)    N11(24)
               /\                                   /\                          /\         /\
          N4(7) f(7)                           N5(10) d(8)                g(11) c(11) N6(11)  N7(13)
            /\                                  /\                                     /\         /\
      N1(3)    N2(4)                         p(5) l(5)                              b(5) u(6) N3(6) m(7)
      /\        /\                                                                             /\
  y(1) x(2)  w(2) q(2)                                                                      z(3) v(3)
```

**Huffman codes:**

| char | code
| :- | :-
| t | 000
| i | 001
| e | 011
| o | 0101
| f | 01001
| y | 0100000
| x | 0100001
| w | 0100010
| q | 0100011
| n | 1000
| h | 1001
| r | 1011
| d | 10101
| p | 101000
| l | 101001
| a | 1100
| s | 1101
| g | 11110
| c | 11111
| b | 111100
| u | 111101
| m | 111111
| z | 1111100
| v | 1111101

\newpage

#### 4. Use Lempel-Ziv to decode the following binary code string (account for whitespace):

010000 010010 001111 000010 000001 000010 001100 000101 000000 001001 001101 010000 001111 010011 010011 001001 000010 001001 001100 001001 010100 001001 000101 010011 000000 000001 010010 100010 010100 001111 000000 000010 100010 011011 000101 000110 000101 010010 110101 000100 000000 110111 100011 100101 011100 011110 100000 111011 100111 101001 101011 101101 101111 110001

a. probable impossibilities are to be performed

b. I took the provided pseudocode in the lecture notes and came up with this C++:
```
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using std::ifstream;
using std::stringstream;
using std::string;
using std::cout;
using std::endl;

// initialize the dictionary
void initializeDictionary(string dictionary[64], int& dictSize) {
    dictionary[0] = " ";  // whitespace as the first entry
    for (int i = 0; i < 26; ++i) {
        dictionary[i + 1] = string(1, 'a' + i);  // a-z
    }
    dictSize = 27;  // initial dictionary size
}

// convert a binary string to an integer
int binaryToInt(const string& binary) {
    int value = 0;
    for (char c : binary) {
        value = value * 2 + (c - '0');  // convert each bit to int
    }
    return value;
}

// decode function
string decode(const string& binaryString, string dictionary[64], int& dictSize) {
    stringstream ss(binaryString);  // use stringstream to process codes
    string code;                    // for storing each 6-bit code
    string decodedMessage;
    string preWord, curWord;

    // read the first code
    if (ss >> code) {
        int codeInt = binaryToInt(code);
        curWord = dictionary[codeInt];
        decodedMessage += curWord;
        preWord = curWord;
    }

    // process remaining codes
    while (ss >> code) {
        int codeInt = binaryToInt(code);
        curWord = dictionary[codeInt];
        decodedMessage += curWord;

        // create new dictionary entry
        if (dictSize < 64) {
            string codeWord = preWord + curWord[0];
            dictionary[dictSize++] = codeWord;
        }

        preWord = curWord;
    }

    return decodedMessage;
}

int main() {
    // open the input file
    ifstream inputFile("code.txt");
    if (!inputFile) {
        cout << "Error: Unable to open file code.txt." << endl;
        return 1;
    }

    // read the binary string
    string binaryString, temp;
    while (getline(inputFile, temp)) {
        binaryString += temp + " ";  // concatenate lines with a space
    }
    inputFile.close();

    // initialize dictionary
    string dictionary[64];
    int dictSize = 0;
    initializeDictionary(dictionary, dictSize);

    // decode the binary string
    string decodedMessage = decode(binaryString, dictionary, dictSize);

    // output the decoded message
    cout << "Decoded message: " << decodedMessage << endl;

    return 0;
}
```

\newpage

#### 5. Draw a standard trie and a compressed trie to store:

{compassion, concern, confidence, consideration, content, honest, honor, humility, integrity, intelligence, modesty, morality }

a. standard trie:
```
(root)
 |                   \               \       \
'c'                  'h'             'i'     'm'
 |                    |      \        |       |
'o'                  'o'     'u'     'n'     'o'
 |  \                 |       |       |       |  \
'm' 'n'              'n'     'm'     't'     'd' 'r'
 |   |   \   \   \    |  \    |  \    |       |   |
'p' 'c' 'f' 's' 't'  'e' 'o' 'i' 'o' 'e'     'e' 'a'
 |   |   |   |   |    |   |   |   |   |  \    |   |
'a' 'e' 'i' 'i' 'e'  's' 'r' 'l' 'r' 'g' 'l' 's' 'l'
 |   |   |   |   |    |       |       |   |   |   |
's' 'r' 'd' 'd' 'n'  't'     'i'     'r' 'l' 't' 'i'
 |   |   |   |   |    |       |       |   |   |   |
's' 'n' 'e' 'e' 't'  'y'     't'     'i' 'i' 'y' 't'
 |       |   |                |       |   |       |
'i'     'n' 'r'              'y'     't' 'g'     'y'
 |       |   |                        |   |
'o'     'c' 'a'                      'y' 'e'
 |       |   |                            |
'n'     'e' 't'                          'n'
             |                            |
            'i'                          'c'
             |                            |
            'o'                          'e'
             |
            'n'
```

\newpage

b. compressed trie:
```
(root)
|
"co"
|           \
"mpassion"  "n"
             |      \         \
             "cern" "fidence" "sideration"

(root)
|
"h"
|           \
"on"        "um"
|     \      |     \
"esty" "or" "ility" "or"

(root)
|
"inte"
|       \
"grity" "lligence"

(root)
|
"mo"
|       \
"desty" "rality"
```

**Please note that for b. above, the drawing is a representation of the four resulting subtrees, and the (root) is same for all four.**

\newpage

#### 6. Based on the directed and weighted graph given in the assignment:
a. Draw the adjacent matrix:

| | A | B | C | D | E | F | G | H | I | J | K
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :-
| A | 0 | 21 | 0 | 16 | 0 | 0 | 0 | 0 | 0 | 0 | 0
| B | 0 | 0 | 0 | 0 | 13 | 0 | 0 | 0 | 0 | 0 | 0
| C | 7 | 0 | 0 | 0 | 0 | 0 | 15 | 0 | 0 | 0 | 0
| D | 0 | 0 | 0 | 0 | 12 | 0 | 10 | 8 | 0 | 0 | 0
| E | 0 | 0 | 12 | 0 | 0 | 0 | 0| 0 | 0 | 0 | 37
| F | 0 | 27 | 0 | 0 | 17 | 0 | 0 | 0 | 0 | 0 | 0
| G | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 19 | 0
| H | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 28 | 25 | 23
| I | 0 | 0 | 0 | 0 | 0 | 39 | 0 | 0 | 0 | 0 | 0
| J | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
| K | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0

b. Show the adjacent vertices list of each vertex:
```
A: [(B, 21), (D, 16)]
B: [(E, 13)]
C: [(A, 7), (G, 15)]
D: [(E, 12), (G, 10), (H, 8)]
E: [(C, 12), (K, 37)]
F: [(B, 27), (E, 17)]
G: [(J, 19)]
H: [(I, 28), (J, 25), (K, 23)]
I: [(F, 39)]
J: []
K: []
```

c. Show the order of vertices in a DFS traversal from A.

**Utilizing the adjacency list:**

1. Start at **A**, mark as visited: `Visited: [A]`.

2. Move to **B** (adjacent to A), mark as visited: `Visited: [A, B]`.

3. Move to **E** (adjacent to B), mark as visited: `Visited: [A, B, E]`.

4. Move to **C** (adjacent to E), mark as visited: `Visited: [A, B, E, C]`.

5. Move to **G** (adjacent to C), mark as visited: `Visited: [A, B, E, C, G]`.

6. Move to **J** (adjacent to G), mark as visited: `Visited: [A, B, E, C, G, J]`.

7. Backtrack to G, no unvisited adjacent nodes, backtrack further until E.

8. From E, move to **K** (adjacent to E), mark as visited: `Visited: [A, B, E, C, G, J, K]`.

9. Backtrack all the way to A.

10. From A, move to **D** (adjacent to A), mark as visited: `Visited: [A, B, E, C, G, J, K, D]`.

11. From D, move to **H** (adjacent to D), mark as visited: `Visited: [A, B, E, C, G, J, K, D, H]`.

12. From H, move to **I** (adjacent to H), mark as visited: `Visited: [A, B, E, C, G, J, K, D, H, I]`.

13. From I, move to **F** (adjacent to I), mark as visited: `Visited: [A, B, E, C, G, J, K, D, H, I, F]`.

**Final DFS Traversal Order:** `[A, B, E, C, G, J, K, D, H, I, F]`.

\newpage

d. Show the order of vertices in BFS traversal from A.

**Utilizing the adjacency list:**

1. Start at **A**, mark as visited, and enqueue it:
    `Queue: [A], Visited: [A]`

2. Dequeue **A** and visit its neighbors **B** and **D**:
    `Queue: [B, D], Visited: [A, B, D]`

3. Dequeue **B** and visit its neighbor **E**:
    `Queue: [D, E], Visited: [A, B, D, E]`

4. Dequeue **D** and visit its neighbors **G** and **H**:
    `Queue: [E, G, H], Visited: [A, B, D, E, G, H]`

5. Dequeue **E** and visit its neighbors **C** and **K**:
    `Queue: [G, H, C, K], Visited: [A, B, D, E, G, H, C, K]`

6. Dequeue **G** and visit its neighbor **J**:
    `Queue: [H, C, K, J], Visited: [A, B, D, E, G, H, C, K, J]`

7. Dequeue **H** and visit its neighbor **I**:
    `Queue: [C, K, J, I], Visited: [A, B, D, E, G, H, C, K, J, I]`

8. Dequeue **C**, **K**, **J**, and **I** in turn. No new vertices are visited as their neighbors are already visited or they have none.

**Final BFS Traversal Order:** `[A, B, D, E, G, H, C, K, J, I]`.

\newpage

e. Draw the minimum spanning tree of the graph, treating edges as undirected.
```
Edges by Weight:
A -- C (7)
D -- H (8)
D -- G (10)
D -- E (12)
B -- E (13)
C -- G (15)
A -- D (16)
E -- F (17)
G -- J (19)
A -- B (21)
H -- K (23)
H -- J (25)
B -- F (27)
H -- I (28)
E -- K (37)
F -- I (39)
```

Using **Kruskal's Algorithm** (sparse graph, edge list):
```
A -- C OK
D -- H OK
D -- G OK
D -- E OK
B -- E OK
C -- G OK
A -- D CYCLE CREATED, DISCARD
E -- F OK
G -- J OK
A -- B CYCLE CREATED, DISCARD
H -- K OK
H -- J CYCLE CREATED, DISCARD
B -- F CYCLE CREATED, DISCARD
H -- I OK
E -- K CYCLE CREATED, DISCARD
F -- I CYCLE CREATED, DISCARD
```

Resulting tree:
```
       A 
      /
     C 
    /
   G  
 /   \
J     D
    /   \
   H     E 
  / \   / \
 K   I F   B
```

**Verification:**

- Edges remaining: 10 (11 - 1)

- No cycles

- All nodes connected